/***********************************
 * Tespel grammar
 * this version has simple start condition
 * it is only possible to start when a dstm
 * state or transition is covered
 ************************************/
Package org.prgmdl.tespel;

Helpers
// Special chars and other stuffs
nlw = 0x0D 0x0A;
nll = 0x0A;
tab1 = '\t';
tab2 = 0x09;
sp = ' ';
ignore_one = '\r';
echar = [[['a'..'z']+['A'..'Z']]+'_'];
char = ['a'..'z'];
digit = ['0'..'9'];
dc = '_';
dollar = '$';


Tokens
// Binary logical and comparison operators
assign = '=';
eq = '==';
neq = '!=';
ge = '>=';
gt = '>';
le = '<=';
lt = '<';
and = '&&';
or = '||';
not = '!';

// Structural operators
comma = ',';
semi = ';';
coloncolon ='::';
dot = '.';
colon = ':';
ob = '{';
cb = '}';
sob = '[';
scb = ']';
rob = '(';
rcb = ')';

// Defintion of identifiers, numbers and elementary literals
identifier = char (digit | echar)* ;
externalidentifier = dollar (digit | echar)* ;
number = digit*;
true = 'True';
false = 'False';

// Keywords
speckey = 'Tespel';
ofkey = 'Of';
onkey = 'On';
fromkey = 'From';
intkey = 'Int';
boolkey = 'Boolean';
dckey = dc;
mdlkey = 'Mdl';
recvkey =  '<-';
sendkey = '->';
dstmstatekey = 'DSTM.node';
dstmboxkey = 'DSTM.box';
dstmtranskey = 'DSTM.transition';
coverkey = 'Cover';
notcoverkey = 'Notcover';
nextkey = 'Next';
setkey = 'Set';
assertkey = 'Assert';
loopkey = 'Loop';
anykey = 'Any';
choicekey = 'Choice';
andkey = 'And';

// Mathematical binary and unary operators
plus = '+';
minus = '-';
star='*';
slash='/';	

// Comments & co.
blank = (sp | tab1 | tab2 | nlw | nll | ignore_one)+;

Ignored Tokens
blank;

Productions
spec = 
	{full} speckey tespelname ofclause onclause? fromclause? ob body cb;

tespelname =
	{id} blockunique;

ofclause =
	{plain} ofkey modelname;

modelname =
	{id} externalidentifier;

onclause =
	{plain} onkey reqname;

reqname =
	{id} externalidentifier;

fromclause = 
	{plain} fromkey structuralcond;

structuralcond = 
	{nested} rob structuralcond rcb |
	{unary}  rob not structuralcond rcb |
	{simple} astructuralcond |
	{binary} rob lstructuralcond binop rstructuralcond rcb;
		
lstructuralcond =
	{left} structuralcond;
		
rstructuralcond =
	{right} structuralcond;

astructuralcond =
	{state} dstmstatekey equiop dstmitemvalue |
	{box} dstmboxkey equiop dstmitemvalue |
	{transition} dstmtranskey equiop dstmitemvalue;

dstmitemvalue = 
	{plain} machinename dot modelelementname;

modelelementname = 
	{id} externalidentifier;

machinename = 
	{id} externalidentifier;

body = 
	{simple} lvars block;

lvars =
	{concat} var*;
	
var =
	{bool} boolkey vardef defaultbool? semi |
	{int} intkey vardef defaultint? semi;

defaultbool =
	{simple} assign boolvalue;

boolvalue =
	{tr} true |
	{fa} false;
	
defaultint =
	{num} assign number;

block =
	{block} blockdef ob mstep* cb;

mstep = 
	{transition} transdef colon fromstep sendkey tostep check? semi |
	{cover} stepdef coverkey dstmitemvalue semi |  
	{notcover} stepdef notcoverkey dstmitemvalue semi |  
	{next} stepdef nextkey dstmitemvalue semi |  
	{loop} stepdef loopkey number ob block cb |  
	{choice} stepdef choicekey ob blocks cb |  
	{set} stepdef setkey stmt semi |  
	{assert} stepdef assertkey fullcond semi |  
	{and} stepdef andkey ob blocks cb |  
	{any} stepdef anykey ob blocks cb ;  

blocks =
	{sequence} block*;

check = 
	{simple} onkey intcond;

intcond =
	{nested} rob intcond rcb |
	{not} not intcond |
	{binop} rob lintcond binop rintcond rcb |
	{atomic} aintcond;

lintcond =
	{left} intcond;
	
rintcond =
	{right} intcond;
	
aintcond =
	{literal} boolvalue |
	{equiop} linttrm equiop rinttrm |
	{compop} linttrm cmpop rinttrm;

linttrm = 
	{simple} varexpr |
	{math} varexpr mathop linttrm;

rinttrm = 
	{simple} varexpr |
	{math} varexpr mathop rinttrm;

varexpr =
	{literal} boolvalue |
	{id} varuse |
	{num} number;

stmt =
	{assign} varuse assign stmtexpr;

stmtexpr = 
	{nestedl} rob stmtexpr rcb|
	{boolnot} not stmtexpr |
	{boolop} rob lstmtexpr binop rstmtexpr rcb |
	{compare} rob lstmtexpr cmpop rstmtexpr rcb |
	{mathop} rob lstmtexpr mathop rstmtexpr rcb |
	{eqiv} rob lstmtexpr equiop rstmtexpr rcb |
	{atom} astmtexpr;

lstmtexpr =
	{plain} stmtexpr;
		
rstmtexpr =
	{plain} stmtexpr;
	
astmtexpr =
	{tr} true |
	{fa} false |
	{id} varuse |
	{num} number;

fullcond =
	{nested} rob fullcond rcb |
	{not} not fullcond |
	{binop} rob lfullcond binop rfullcond rcb |
	{atomic} afullcond;

lfullcond =
	{left} fullcond;
	
rfullcond =
	{right} fullcond;
	
afullcond =
	{literal} boolvalue |
	{recv} mdlkey recvkey lt msgterms gt onkey chname|
	{send} mdlkey sendkey lt msgterms gt onkey chname;

msgterms =
	{simple} msgterm |
	{complex} msgterm comma msgterms;

msgterm = 
	{true} true |
	{false} false |
	{num} number |
	{dcare} dckey |
	{enum} ename coloncolon eliteral;
	
equiop = 
	{eq} eq |
	{neq} neq;

binop = 
	{andop} and |
	{orop} or;

mathop =
	{plus} plus|
	{minus} minus|
	{star} star|
	{slash} slash;

cmpop =
	{lteq} le |
	{lt} lt |
	{gteq} ge |
	{gt} gt;

chname =
	{id} externalidentifier;

ename =
	{id} externalidentifier;

eliteral =
	{id} externalidentifier;

fromstep =
	{id} blockdefined;
	
tostep =
	{id} blockdefined;

varuse =
	{id} blockdefined;

transdef = 
	{id} blockunique;

blockdef =
	{id} blockunique;

stepdef =
	{id} blockunique;

vardef =
	{id} blockunique;

blockunique = 
	{id} identifier;

blockdefined = 
	{id} identifier;